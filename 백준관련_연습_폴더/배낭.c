// 여행에 필요한 물건인 n개의 물건이 있음
// 물건에는 각각 무게 W, 가치 V를 가짐
// 여행가서 v만큼 즐길수 있음

// 최대 K만큼의 무게만을 넣어 갈수 있음

// 여기서 
// 첫번째 줄에 물품의 수와 버틸수 있는 무게를 입력받고
// 두번째 줄부터 물품의 수까지 배낭에 넣을 물건을 
// 입력 받아서(w,v)

// 물품의 수가 4개 버틸수 있는 무게가 7까지라면

// 물건은
// 무게 6, 기대13
// 무게 4, 기대 8
// 무게 3, 기대 6
// 무게 5, 기대 12

// 라는건데..
// 일단 경우의 수는 4,3인것을 기대값은 합쳐서 14..
// 아하!

// 물품의 수는 반복개념, 무게를 합해서 최대 7을 만들면서
// 기댓값을 합해서 출력하라는뜻!

// 구현고민..

// int n,k; // n = 물품의 수, k = 버틸수 있는 무게
// scanf(); // todo
// int A[n][2]; //  2차원 배열으로 무게, 기댓값 포함 줄(n)
// 마다 무게와 기댓값을 의미

// for(int i = 0; i<n; i++){
// 	for (int j = 0; j<2; j++){
// 		scanf(); // todo
// 	}
// }

// 근데.. 경우의 수가 많아질수록 어떻게 구별할지 모름..
// 항목이 많고 들고갈 무게가 클수록 최댓값을 구하기
// 어려워짐..

// 따라서 계산식이 필요함!
// 일단, QSORT를 한다음에 배열을 반/반으로 가르고
// 첫번째 배열 + 두번째 배열 계산 결과 저 무게를 맞추면
// 되는데.. 이러면 모순점이.. 위처럼 많으면 배열로 안된다..
// 물품의 수가 100개를 넘기지 않으니 위안이지만..

// qsort한 다음에 반으로 쪼개서 중간값에서 가까이 있는 
// 순서대로 더하면 되지 않을까 싶음

// 아! 가치값을 sort해서 큰수부터 더하면 되겠네
// 우선순위는
// 1. 최대 무게
// 2. 가치값
// 3. 물건의 무게

// 경우의 수를 생각해보자면..
// 최대무게 130
// 34
// 23 
// 54
// 19
// 58
// 34

// 이런것처럼 더해서 130이 안나오는 경우와
// 130이 나오는 경우 두가지로 나뉨

// 안나오는 경우는 더해서 값에 근사되는값을 더해서 결과
// 나오는 경우는 기존대로 더해서



// .. 일단 이 문제만 해결하면 선택된 첫번째 배열(해당 무게)
// 에 두번째 배열 결과를 다 더하고 출력만 하면 된다..



#include <stdio.h>


int main(){
    
}